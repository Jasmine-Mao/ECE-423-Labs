//
//  mjpeg423_decoder.c
//  mjpeg423app
//
//  Created by Rodolfo Pellizzoni on 12/24/13.
//  Copyright (c) 2013 __MyCompanyName__. All rights reserved.
//

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../common/mjpeg423_types.h"
#include "mjpeg423_decoder.h"
#include "../common/util.h"
#include "ff.h"
#include "../ece423_vid_ctl/ece423_vid_ctl.h"

//extern FATFS fatfs;
//extern  FIL fil;

//declaration. Function implemented in libnsbmp
//void encode_bmp(rgb_pixel_t* rgbblock, uint32_t w_size, uint32_t h_size, const char* filename);

//main decoder function
//void mjpeg423_decode(const char* filename_in, const char* filenamebase_out)
void mjpeg423_decode(uint32_t frame_index, video_info_t video)
{
    // initialize stuff
    rgb_pixel_t* rgbblock;
    if((rgbblock = malloc(video.w_size*video.h_size*sizeof(rgb_pixel_t)))==NULL) error_and_exit("cannot allocate rgbblock");
    uint32_t* vdma_reg_status;
    uint32_t num_bytes_read;

    rgbblock = buff_next();

    //read frame payload
    if(f_read(&fil, &video.frame_size, sizeof(uint32_t), &num_bytes_read) != 0) error_and_exit("COULD NOT GET FRAME SIZE");

    if(f_read(&fil, &video.frame_type, sizeof(uint32_t), &num_bytes_read) != 0) error_and_exit("COULD NOT GET FRAME TYPE");

    if(f_read(&fil, &video.Ysize, sizeof(uint32_t), &num_bytes_read) != 0) error_and_exit("COULD NOT READ Y SIZE");
    if(f_read(&fil, &video.Cbsize, sizeof(uint32_t), &num_bytes_read) != 0) error_and_exit("COULD NOT READ CB SIZE");
    if(f_read(&fil, video.Ybitstream, (video.frame_size - 4 * sizeof(uint32_t)), &num_bytes_read) != 0) error_and_exit("COULD NOT READ YBITSTREAM");

    video.Cbbitstream = video.Ybitstream + video.Ysize;
    video.Crbitstream = video.Cbbitstream + video.Cbsize;

    lossless_decode(video.hYb_size*video.wYb_size, video.Ybitstream, video.YDCAC, Yquant, video.frame_type);
    lossless_decode(video.hCb_size*video.wCb_size, video.Cbbitstream, video.CbDCAC, Cquant, video.frame_type);
    lossless_decode(video.hCb_size*video.wCb_size, video.Crbitstream, video.CrDCAC, Cquant, video.frame_type);
    
    //fdct
    for(int b = 0; b < video.hYb_size*video.wYb_size; b++) idct(video.YDCAC[b], video.Yblock[b]);
    for(int b = 0; b < video.hCb_size*video.wCb_size; b++) idct(video.CbDCAC[b], video.Cbblock[b]);
    for(int b = 0; b < video.hCb_size*video.wCb_size; b++) idct(video.CrDCAC[b], video.Crblock[b]);
    


    //ybcbr to rgb conversion
    for(int b = 0; b < video.hCb_size*video.wCb_size; b++)
        ycbcr_to_rgb(b/video.wCb_size*8, b%video.wCb_size*8, video.w_size, video.Yblock[b], video.Cbblock[b], video.Crblock[b], rgbblock);


    vdma_reg_status = buff_reg();
    vdma_out();
    DEBUG_PRINT("\nDecoder done.\n\n\n")
    //close down
    //fclose(file_in);
    //f_close(&fil);
    //vdma_close();
    free(rgbblock);
    // free(Yblock);
    // free(Cbblock);
    // free(Crblock);
    // free(YDCAC);
    // free(CbDCAC);
    // free(CrDCAC);
    // free(Ybitstream);
    // these frees need to be in the cycle vide function
}
