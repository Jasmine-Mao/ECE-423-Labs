#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../common/mjpeg423_types.h"
#include "mjpeg423_decoder.h"
#include "../common/util.h"
#include "ff.h"
#include "../ece423_vid_ctl/ece423_vid_ctl.h"
#include "video_control.h"

static FATFS fatfs;
static FIL fil;

typedef struct {
    uint32_t num_frames;
    uint32_t w_size;
    uint32_t h_size;
    uint32_t num_iframes;
    uint32_t payload_size;
    uint32_t Ysize;
    uint32_t Cbsize;
    uint32_t frame_size;
    uint32_t frame_type;
    int hCb_size;
    int wCb_size;
    int hYb_size;
    int wYb_size;
    iframe_trailer_t* trailer;
    color_block_t* Yblock;
    color_block_t* Cbblock;
    color_block_t* Crblock;
    dct_block_t* YDCAC;
    dct_block_t* CbDCAC;
    dct_block_t* CrDCAC;
} video_info_t;

video_info_t load_video(const TCHAR* file_name)
{
    uint32_t num_frames, w_size, h_size, num_iframes, payload_size;
    uint32_t Ysize, Cbsize, frame_size, frame_type;

    //open file
    status = f_open(&fil, file_name, FA_READ); //change to filename_in to generalize later on
    uint32_t num_bytes_read;

    //read header
    if(f_read(&fil, &num_frames, sizeof(uint32_t), &num_bytes_read) != 0) error_and_exit("FAILED TO READ NUMBER OF FRAMES");
    if(f_read(&fil, &w_size, sizeof(uint32_t), &num_bytes_read) != 0) error_and_exit("FAILED TO READ WIDTH");
    if(f_read(&fil, &h_size, sizeof(uint32_t), &num_bytes_read) != 0) error_and_exit("FAILED TO READ HEIGHT");
    if(f_read(&fil, &num_iframes, sizeof(uint32_t), &num_bytes_read) != 0) error_and_exit("FAILED TO READ NUM I-FRAMES");
    if(f_read(&fil, &payload_size, sizeof(uint32_t), &num_bytes_read) != 0) error_and_exit("FAILED TO READ PAYLOAD SIZE");

    //read traler
    int hCb_size = h_size/8;           //number of chrominance blocks
    int wCb_size = w_size/8;
    int hYb_size = h_size/8;           //number of luminance blocks. Same as chrominance in the sample app
    int wYb_size = w_size/8;

    //trailer structure
    iframe_trailer_t* trailer = malloc(sizeof(iframe_trailer_t)*num_iframes);

    //main data structures. See lab manual for explanation
    //gb_pixel_t* rgbblock;
    // rgbblock = buff_next(); this is probably wrong
    //if((rgbblock = malloc(w_size*h_size*sizeof(rgb_pixel_t)))==NULL) error_and_exit("cannot allocate rgbblock");
    color_block_t* Yblock;
    if((Yblock = malloc(hYb_size * wYb_size * 64))==NULL) error_and_exit("cannot allocate Yblock");
    color_block_t* Cbblock;
    if((Cbblock = malloc(hCb_size * wCb_size * 64))==NULL) error_and_exit("cannot allocate Cbblock");
    color_block_t* Crblock;
    if((Crblock = malloc(hCb_size * wCb_size * 64))==NULL) error_and_exit("cannot allocate Crblock");;
    dct_block_t* YDCAC;
    if((YDCAC = malloc(hYb_size * wYb_size * 64 * sizeof(DCTELEM)))==NULL) error_and_exit("cannot allocate YDCAC");
    dct_block_t* CbDCAC;
    if((CbDCAC = malloc(hCb_size * wCb_size * 64 * sizeof(DCTELEM)))==NULL) error_and_exit("cannot allocate CbDCAC");
    dct_block_t* CrDCAC;
    if((CrDCAC = malloc(hCb_size * wCb_size * 64 * sizeof(DCTELEM)))==NULL) error_and_exit("cannot allocate CrDCAC");
    //Ybitstream is assigned a size sufficient to hold all bistreams
    //the bitstream is then read from the file into Ybitstream
    //the remaining pointers simply point to the beginning of the Cb and Cr streams within Ybitstream
    uint8_t* Ybitstream;
    if((Ybitstream = malloc(hYb_size * wYb_size * 64 * sizeof(DCTELEM) + 2 * hCb_size * wCb_size * 64 * sizeof(DCTELEM)))==NULL) error_and_exit("cannot allocate bitstream");
    uint8_t* Cbbitstream;
    uint8_t* Crbitstream;

    //read trailer. Note: the trailer information is not used in the sample decoder app
    //set file to beginning of trailer
    //if(fseek(file_in, 5 * sizeof(uint32_t) + payload_size, SEEK_SET) != 0) error_and_exit("cannot seek into file");
    if(f_lseek(&fil, 5 * sizeof(uint32_t) + payload_size) != 0) error_and_exit("ERROR GETTING TO TRAILER");
    for(int count = 0; count < num_iframes; count++){
    	if(f_read(&fil, &(trailer[count].frame_index), sizeof(uint32_t), &num_bytes_read) != 0) error_and_exit("FAILED TO GET FRAME INDEX");
//        if(fread(&(trailer[count].frame_index), sizeof(uint32_t), 1, file_in) != 1) error_and_exit("cannot read input file");

    	if(f_read(&fil, &(trailer[count].frame_position), sizeof(uint32_t), &num_bytes_read) != 0) error_and_exit ("FAILED TO GET FRAME POSITION");
//        if(fread(&(trailer[count].frame_position), sizeof(uint32_t), 1, file_in) != 1) error_and_exit("cannot read input file");
        //DEBUG_PRINT_ARG("I frame index %u, ", trailer[count].frame_index)
        //DEBUG_PRINT_ARG("position %u\n", trailer[count].frame_position)
    }
    //set it back to beginning of payload
//    if(fseek(file_in,5 * sizeof(uint32_t),SEEK_SET) != 0) error_and_exit("cannot seek into file");
    if(f_lseek(&fil, 5 * sizeof(uint32_t)) != 0) error_and_exit("COULD NOT SEEK BACK TO BEGINNING");
}

void display_next_frame(uint32_t* frame_index){
	// basically just runs decoder

}

void pause_button(uint8_t* not_paused_ptr){
	// when pressed, this should suspend the
	*not_paused_ptr = !(*not_paused_ptr);
}
